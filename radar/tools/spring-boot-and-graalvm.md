---
title: "GraalVM"
ring: adopt
quadrant: "tools"
tags: [java,backend]
---
The General Recursive Applicative and Algorithmic Language Virtual Machine (Graal VM) is a high-performance JDK distribution written for Java and other JVM languages, along with support for JavaScript, Ruby, Python, and several other languages. It provides a Native Image builder –  a tool to build native code from Java applications and package it together with the VM into a standalone executable. It is officially supported by the Spring Boot Maven and Gradle Plugin with a few exceptions.

GraalVM Native Images are standalone executables that can be generated by processing compiled Java applications ahead-of-time. Native Images generally have a smaller memory footprint and start faster than their JVM counterparts.
[Spring Boot Native](https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html)

### Key features:

- **Native Images** A native image is a standalone executable that includes the application classes, classes from its dependencies, runtime library classes, and statically linked native code from JDK. The JVM is packaged into the native image, eliminating the need for a Java Runtime Environment at the target system.

- **Ahead-of-Time Compilation** GraalVM compiles Java applications ahead of time into standalone binaries. These binaries are smaller, start up to 100x faster, provide peak performance with no warmup, and use less memory and CPU than applications running on a Java Virtual Machine (JVM)12.

- **Reduced Attack Surface** GraalVM reduces the attack surface of your application. It excludes unused classes, methods, and fields from the application binary. It restricts reflection and other dynamic Java language features to build time only. It does not load any unknown code at run time.

- **Support for Microservices Frameworks and Cloud Platforms** Popular microservices frameworks such as Spring Boot, Micronaut, Helidon, and Quarkus, and cloud platforms such as Oracle Cloud Infrastructure, Amazon Web Services, Google Cloud Platform, and Microsoft Azure all support GraalVM.

- **Profile-Guided Optimization and G1 Garbage Collector** With profile-guided optimization and the G1 (Garbage-First) garbage collector, you can get lower latency and on-par or better peak performance and throughput compared to applications running on a JVM.

- **Licensing and Support** GraalVM Community Edition is open-source software built from the sources available on GitHub and distributed under version 2 of the GNU General Public License with the "Classpath" Exception.

[GraalVM](https://www.graalvm.org/latest/docs/introduction/)

### Enterprise use cases
A lot of companies are using GraalVM as a performance booster [https://www.graalvm.org/use-cases/](https://www.graalvm.org/use-cases/), for example Disney use native image compilation to reduce cold startup time of [AWS lambda](https://aws.amazon.com/it/blogs/opensource/improving-developer-productivity-at-disney-with-serverless-and-open-source/) based on Java.

### Tips & Tricks
#### Reflection
Native image compilation as some limitations regarding the usage of refelections cause it need all class information at build time. To solve this issue the GraalVM community offers the "reachibility metadata" for the most common libraries. Frameworks like SpringBoot and Quarkus also allows to generate metadata for reflections by using dedicated API, for example in Spring you can use [RuntimeHintsRegistrar](https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.advanced.custom-hints). When there isn't reachibility metada for a particular library, GraalVM offers an [agent](https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.advanced.using-the-tracing-agent) to capture metadata.

#### Frameworks
Spring Boot and Quarkus already supports GraalVM native image by relying on AOT compiler. There is some "guideline" to follows in order to successfuly get a running native image:
- Spring Boot: https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-with-GraalVM
- Quarkus: https://quarkus.io/guides/writing-native-applications-tips

Also, the adoption of OpenTelemetry as an observability instrumentation tool over a Java stack based microservice is a key enabler to native image of microservice. This is due to missing support , by GraalVM native compilation, to java agents, which is the main way to instrument java microservices.

### Our use cases:

- (https://github.com/pagopa/rtd-ms-sender-auth) The Sender Auth is a µ-service responsible to store the association between sender code and api key, and the last version was deployed using a GraalVM. It's up and running, and here is possible to check the code.

- [cstar-mock-io](https://github.com/pagopa/cstar-io-mock) a microservice which generate JWT token for test purposes. It's written using SpringBoot with reactive stack.